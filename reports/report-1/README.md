# Задание
1. Сгенерировать любым способ 1,000,000 анкет. Имена и Фамилии должны быть реальными, чтобы учитывать селективность индекса. Так же можно воспользовать уже готовым списком как основой.
1. Реализовать функционал поиска анкет по префиксу имени и фамилии (одновременно) в вашей социальной сети (реализовать метод /user/search из спецификации) (запрос в форме firstName LIKE ? and secondName LIKE ?). Сортировать вывод по id анкеты.
1. Провести нагрузочные тесты этого метода. Поиграть с количеством одновременных запросов. 1/10/100/1000.
1. Построить графики и сохранить их в отчет
1. Сделать подходящий индекс.
1. Повторить пункт 3 и 4.
1. В качестве результата предоставить отчет в котором должны быть:
 - графики latency до индекса;
 - графики throughput до индекса;
 - графики latency после индекса;
 - графики throughput после индекса;
 - запрос добавления индекса;
 - explain запросов после индекса;
 - объяснение почему индекс именно такой;


# Отчет по результатам нагрузочного тестирования

## Введение
Цель тестирования заключается в оценке производительности метода поиска пользователей `/user/search` в зависимости от количества одновременных запросов до и после добавления индекса.

## Описание системы
Тестируемая система представляет собой веб-приложение, реализованное на языке программирования Go с использованием базы данных PostgreSQL. Приложение предоставляет API для поиска пользователей по префиксу имени и фамилии.

## Методология
Для проведения нагрузочного тестирования использовался инструмент JMeter. Были проведены тесты с количеством одновременных пользователей: 1, 10, 100 и 1000. Каждый тест длился 30 секунд, и использовались следующие параметры:
- Метод: GET
- URL: `http://localhost:8080/user/search`
- Параметры запроса: `first_name=Абрамов&last_name=Александр`

## Результаты тестирования

### До индекса

| Количество пользователей | Latency (мс) | Throughput (запросов/сек) |
|--------------------------|--------------|--------------------------|
| 1                        | 221          | 4.5                      |
| 10                       | 867          | 7.6                      |
| 100                      | 10879        | 8.5                      |
| 1000                     | 6159         | 55.6                     |

### После индекса

| Количество пользователей | Latency (мс) | Throughput (запросов/сек) |
|--------------------------|--------------|--------------------------|
| 1                        | 205          | 4.9                      |
| 10                       | 1081         | 7.4                      |
| 100                      | 1076         | 23.6                     |
| 1000                     | 6313         | 58.1                     |

## Анализ результатов
- При 1 и 10 пользователях добавление индекса незначительно повлияло на производительность.
- При 100 пользователях добавление индекса значительно улучшило производительность, уменьшив latency и увеличив throughput.
- При 1000 пользователях добавление индекса также улучшило производительность, хотя увеличение latency было минимальным.

```
-
 Sort  (cost=54538.15..54538.16 rows=1 width=100) (actual time=231.068..239.508 rows=0 loops=1)
   Sort Key: id
   Sort Method: quicksort  Memory: 25kB
   ->  Gather  (cost=1000.00..54538.14 rows=1 width=100) (actual time=231.004..239.443 rows=0 loops=1)
         Workers Planned: 2
         Workers Launched: 2
         ->  Parallel Seq Scan on users  (cost=0.00..53538.04 rows=1 width=100) (actual time=225.260..225.260 rows=0 loops=3)
               Filter: (((first_name)::text ~~ 'Абрамов%'::text) AND ((last_name)::text ~~ 'Александр%'::text))
               Rows Removed by Filter: 863773
 Planning Time: 10.990 ms
 Execution Time: 241.796 ms
(11 rows)
```

## Добавление индекса
Индекс был добавлен на столбцы first_name и last_name:

```sql
CREATE INDEX idx_users_first_last_name ON users (first_name, last_name);
```
```
-
 Sort  (cost=54481.85..54481.86 rows=1 width=100) (actual time=131.452..135.003 rows=0 loops=1)
   Sort Key: id
   Sort Method: quicksort  Memory: 25kB
   ->  Gather  (cost=1000.00..54481.84 rows=1 width=100) (actual time=131.447..134.997 rows=0 loops=1)
         Workers Planned: 2
         Workers Launched: 2
         ->  Parallel Seq Scan on users  (cost=0.00..53481.74 rows=1 width=100) (actual time=128.028..128.029 rows=0 loops=3)
               Filter: (((first_name)::text ~~ 'Абрамов%'::text) AND ((last_name)::text ~~ 'Александр%'::text))
               Rows Removed by Filter: 863773
 Planning Time: 3.214 ms
 Execution Time: 135.029 ms
(11 rows)
```

## График
<img src="./chart.png"/>

## Заключение

В данном случае мы добавили B-tree индекс на столбцы first_name и last_name в таблице users.

B-tree индекс был выбран из-за его эффективности при выполнении префиксных и диапазонных запросов, универсальности и способности поддерживать высокую производительность при больших объемах данных.

Добавление индекса на столбцы first_name и last_name значительно улучшает производительность при высоких нагрузках (100 пользователей и более), что делает его полезным для масштабируемых систем.
